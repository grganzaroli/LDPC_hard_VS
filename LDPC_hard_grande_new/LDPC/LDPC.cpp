// LDPC.cpp : LDPC-SPA (Sum-Product Algoritm)
//

#include "stdafx.h"
#include <cmath>
#include <time.h>
#include <stdio.h> 
#include <stdlib.h>

#pragma warning (disable: 4996)

//PARA TESTAR OS TAMANHOS GRANDES, DESCOMENTAR AS RESPECTIVAS TABELAS DA NORMA, OS DEFINES E AS LINHAS entre 240 e 320
//Teste para LDPC(8, 4)
/*
#define n 8
#define k 4
#define el_C 4 // numero de 1s por check node
#define max_it 50 // m�ximo de itera��es
int INDX[n-k] = {4,4,4,4};
int C[n-k][el_C] = {{0, 3, 4, 7},{1, 2, 4, 6},{0, 2, 5, 7},{1, 3, 5, 6}}; // matriz de check nodes
//int in[n] =  {0, 0, 0, 1, 1, 0, 0, 0}; // palavra-código recebida
int in[n] =  {0, 1, 0, 1, 1, 0, 0, 0}; // palavra-código recebida certa de primeira
*/

//Teste para LDPC(8, 4) (http://www.bernh.net/media/download/papers/ldpc.pdf)
/*
#define n 8
#define k 4
#define el_C 4 // numero de 1s por check node
#define max_it 50 // m�ximo de itera��es
int INDX[n-k] = {4,4,4,4};
int C[n-k][el_C] = {{1, 3, 4, 7},{0, 1, 2, 5},{2, 5, 6, 7},{0, 3, 4, 6}}; // matriz de check nodes
//int in[n] =  {1, 1, 0, 1, 0, 1, 0, 1}; // palavra-código recebida
int in[n] =  {1, 0, 0, 1, 0, 1, 0, 1}; // palavra-código recebida certa de primeira
*/

//Teste para LDPC(8, 4) IRREGULAR
/*
#define n 8
#define k 4
#define el_C 5 // numero maximo de 1s por check node
#define max_it 50 // m�ximo de itera��es
int INDX[n-k] = {4,5,3,4};
int C[n-k][el_C] = {{0, 3, 4, 7, -1},{1, 2, 4, 6, 7},{0, 2, 5, -1, -1},{1, 3, 5, 6, -1}}; // matriz de check nodes
//int in[n] =  {0, 0, 0, 1, 1, 0, 0, 0}; // palavra-código recebida
int in[n] =  {0, 1, 0, 1, 1, 0, 0, 0}; // palavra-código recebida certa de primeira
*/

//Teste para LDPC(7, 4)
/*
#define n 7
#define k 4
#define el_C 4 // numero de 1s por check node
#define max_it 50 // m�ximo de itera��es
int INDX[n-k] = {4,4,4};
int C[n-k][el_C] = {{0, 1, 3, 4},{0, 2, 3, 5},{1, 2, 3, 6}}; // matriz de check nodes
//int in[n] =  {1, 1, 0, 1, 0, 1, 1}; // palavra-código recebida
int in[n] =  {1, 1, 0, 0, 0, 1, 1}; // palavra-código recebida certa de primeira
*/

//LDPC 2/3 (64800, 43200) DVBT2
/*
#define n 64800
#define k 43200
#define el_C 8 // numero maximo de 1s por check node
#define max_it 50 // m�ximo de itera��es
#define Q_ldpc 60 //constante que vem da norma
int **C_i; // matriz de troca de bits, que será calculada
int *INDX_i; // indices para calcular a matriz C_i, numero de troca de bits por linha
int **C; // matriz de check nodes, que será calculada
int *INDX; // indices para calcular a matriz C, numero de 1s por linha
int *aux_indx; // indice auxiliar para calcular C
*/

//LDPC 2/3 (16200, 10800) DVBT2

#define n 16200
#define k 10800
#define el_C 8 // numero maximo de troca de bits por check node
#define max_it 50 // m�ximo de itera��es
#define Q_ldpc 15 //constante que vem da norma
int **C_i; // matriz de troca de bits, que será calculada
int *INDX_i; // indices para calcular a matriz C_i, numero de troca de bits por linha
int **C; // matriz de check nodes, que será calculada
int *INDX; // indices para calcular a matriz C, numero de 1s por linha
int *aux_indx; // indice auxiliar para calcular C


using namespace std;

int _tmain(int argc, _TCHAR* argv[])
{

	//TABELA DA NORMA 

	//2/3 64800
	/*
	int T[120][13] = {{317, 2255, 2324, 2723, 3538, 3576, 6194, 6700, 9101, 10057, 12739, 17407, 21039},
	{1958, 2007, 3294, 4394, 12762, 14505, 14593, 14692, 16522, 17737, 19245, 21272, 21379},
	{127, 860, 5001, 5633, 8644, 9282, 12690, 14644, 17553, 19511, 19681, 20954, 21002},
	{2514, 2822, 5781, 6297, 8063, 9469, 9551, 11407, 11837, 12985, 15710, 20236, 20393},
	{1565, 3106, 4659, 4926, 6495, 6872, 7343, 8720, 15785, 16434, 16727, 19884, 21325},
	{706, 3220, 8568, 10896, 12486, 13663, 16398, 16599, 19475, 19781, 20625, 20961, 21335},
	{4257, 10449, 12406, 14561, 16049, 16522, 17214, 18029, 18033, 18802, 19062, 19526, 20748},
	{412, 433, 558, 2614, 2978, 4157, 6584, 9320, 11683, 11819, 13024, 14486, 16860},
	{777, 5906, 7403, 8550, 8717, 8770, 11436, 12846, 13629, 14755, 15688, 16392, 16419},
	{4093, 5045, 6037, 7248, 8633, 9771, 10260, 10809, 11326, 12072, 17516, 19344, 19938},
	{2120, 2648, 3155, 3852, 6888, 12258, 14821, 15359, 16378, 16437, 17791, 20614, 21025},
	{1085, 2434, 5816, 7151, 8050, 9422, 10884, 12728, 15353, 17733, 18140, 18729, 20920},
	{856, 1690, 12787, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{6532, 7357, 9151, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4210, 16615, 18152, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{11494, 14036, 17470, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2474, 10291, 10323, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1778, 6973, 10739, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4347, 9570, 18748, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2189, 11942, 20666, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3868, 7526, 17706, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8780, 14796, 18268, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{160, 16232, 17399, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1285, 2003, 18922, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4658, 17331, 20361, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2765, 4862, 5875, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4565, 5521, 8759, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3484, 7305, 15829, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5024, 17730, 17879, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7031, 12346, 15024, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{179, 6365, 11352, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2490, 3143, 5098, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2643, 3101, 21259, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4315, 4724, 13130, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{594, 17365, 18322, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5983, 8597, 9627, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10837, 15102, 20876, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10448, 20418, 21478, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3848, 12029, 15228, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{708, 5652, 13146, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5998, 7534, 16117, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2098, 13201, 18317, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9186, 14548, 17776, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5246, 10398, 18597, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3083, 4944, 21021, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{13726, 18495, 19921, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{6736, 10811, 17545, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10084, 12411, 14432, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1064, 13555, 17033, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{679, 9878, 13547, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3422, 9910, 20194, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3640, 3701, 10046, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5862, 10134, 11498, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5923, 9580, 15060, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1073, 3012, 16427, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5527, 20113, 20883, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7058, 12924, 15151, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9764, 12230, 17375, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{772, 7711, 12723, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{555, 13816, 15376, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10574, 11268, 17932, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{15442, 17266, 20482, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{390, 3371, 8781, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10512, 12216, 17180, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4309, 14068, 15783, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3971, 11673, 20009, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9259, 14270, 17199, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2947, 5852, 20101, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3965, 9722, 15363, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1429, 5689, 16771, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{6101, 6849, 12781, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3676, 9347, 18761, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{350, 11659, 18342, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5961, 14803, 16123, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2113, 9163, 13443, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2155, 9808, 12885, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2861, 7988, 11031, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7309, 9220, 20745, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{6834, 8742, 11977, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2133, 12908, 14704, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10170, 13809, 18153, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{13464, 14787, 14975, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{799, 1107, 3789, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3571, 8176, 10165, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5433, 13446, 15481, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3351, 6767, 12840, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8950, 8974, 11650, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1430, 4250, 21332, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{6283, 10628, 15050, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8632, 14404, 16916, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{6509, 10702, 16278, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{15900, 16395, 17995, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8031, 18420, 19733, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3747, 4634, 17087, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4453, 6297, 16262, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2792, 3513, 17031, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{14846, 20893, 21563, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{17220, 20436, 21337, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{275, 4107, 10497, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3536, 7520, 10027, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{14089, 14943, 19455, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1965, 3931, 21104, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2439, 11565, 17932, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{154, 15279, 21414, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10017, 11269, 16546, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7169, 10161, 16928, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10284, 16791, 20655, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{36, 3175, 8475, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2605, 16269, 19290, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8947, 9178, 15420, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5687, 9156, 12408, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8096, 9738, 14711, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4935, 8093, 19266, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2667, 10062, 15972, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{6389, 11318, 14417, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8800, 18137, 18434, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5824, 5927, 15314, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{6056, 13168, 15179, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3284, 13138, 18919, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{13115, 17259, 17332, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}};
	*/

	//2/3 16200
	
	int T[30][13] = {{0, 2084, 1613, 1548, 1286, 1460, 3196, 4297, 2481, 3369, 3451, 4620, 2622},
	{1, 122, 1516, 3448, 2880, 1407, 1847, 3799, 3529, 373, 971, 4358, 3108},
	{2, 259, 3399, 929, 2650, 864, 3996, 3833, 107, 5287, 164, 3125, 2350},
	{3, 342, 3529, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 4198, 2147, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5, 1880, 4836, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{6, 3864, 4910, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7, 243, 1542, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8, 3011, 1436, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 2167, 2512, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10, 4606, 1003, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{11, 2835, 705, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{12, 3426, 2365, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{13, 3848, 2474, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{14, 1360, 1743, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 163, 2536, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 2583, 1180, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2, 1542, 509, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 4418, 1005, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 5212, 5117, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5, 2155, 2922, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{6, 347, 2696, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7, 226, 4296, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8, 1560, 487, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 3926, 1640, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10, 149, 2928, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{11, 2364, 563, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{12, 635, 688, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{13, 231, 1684, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{14, 1129, 3894, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}};

	int *in = new int[n]; //vetor de entrada

	C = new int*[n-k]; //matriz C
	for(int i = 0; i < (n-k); i++)
		C[i] = new int[k+1];

	C_i = new int*[n-k]; //matriz C_i
	for(int i = 0; i < (n-k); i++)
		C_i[i] = new int[el_C];

	INDX = new int[n-k]; //vetor INDX
	INDX_i = new int[n-k]; //vetor INDX_i
	aux_indx = new int[n-k]; //vetor aux_indx

	int count = 0;

	//inicializar C e INDX
	for (int j = 0; j < (n-k); j++)
	{
		for (int i = 0; i < el_C; i++)
		{
			C_i[j][i] = -1;
		}
		for (int i = 0; i < (k+1); i++)
		{
			C[j][i] = -1;
		}
		INDX_i[j] = 0;
		INDX[j] = 0;
		aux_indx[j] = 0;
	}

	//for (int j = 0; j < 120; j++) //numero de linhas, LDPC 64800
	for (int j = 0; j < 30; j++) //numero de linhas, LDPC 16200
	{
		for (int kkk = 0; kkk < 360; kkk++) //elementos
		{
			for (int i = 0; i < 13; i++) //elementos em uma linha
			{
				if(T[j][i] != -1)
				{
					C_i[(T[j][i]+kkk*Q_ldpc)%(n-k)][INDX_i[(T[j][i]+kkk*Q_ldpc)%(n-k)]] = count;

					INDX_i[(T[j][i]+kkk*Q_ldpc)%(n-k)] += 1;
				}
			}
			count++;
		}
	}

	int bit; //se inverteu para 0 ou 1

	for(int i = 0; i < k; i++) // para cada i
	{
		bit = 0;
		for(int j = 0; j < (n-k); j++) //para cada p
		{
			if(C_i[j][aux_indx[j]] == i)
			{
				bit = bit^1;
				aux_indx[j]++;
			}

			if(bit == 1)
			{
				C[j][INDX[j]] = i;
				INDX[j]++;
			}
		}
	}

	for (int i = 0; i < (n-k); i++)
	{
		C[i][INDX[i]] = i+k;
		INDX[i]++;
	}

	




	/*
	FILE *F = fopen("matriz_C_i.txt", "w");
	for (int j = 0; j < (n-k); j++)
	{
	for (int i = 0; i < el_C; i++)
	{
	fprintf(F, "%i,", C_i[j][i]);
	}
	fprintf(F, "\n");
	}
	fclose(F);
	printf("OK matriz_C_i\n");
	*/
	/*
	FILE *G = fopen("vetor_INDX_i.txt", "w");
	for (int j = 0; j < (n-k); j++)
	{
	fprintf(G, "%i,", INDX_i[j]);
	}
	fclose(G);
	printf("OK vetor_INDX_i\n");
	*/
	/*
	FILE *f = fopen("matriz_C.txt", "w");
	for (int j = 0; j < (n-k); j++)
	{
	for (int i = 0; i < (n-k); i++)
	{
	fprintf(f, "%i,", C[j][i]);
	}
	fprintf(f, "\n");
	}
	fclose(f);
	printf("OK matriz_C\n");
	*/
	/*
	FILE *g = fopen("vetor_INDX.txt", "w");
	for (int j = 0; j < (n-k); j++)
	{
	fprintf(g, "%i,", INDX[j]);
	}
	fclose(g);
	printf("OK vetor_INDX\n");
	*/











	int pos = -1; // provavel posição do erro
	int aux_pos = -1; // provavel posição do erro (iteracao anterior)

	int** err = new int*[n]; //contagem de erros
	for(int i = 0; i < n; i++)
		err[i] = new int[2];

	int c_node = 0; // bit que o check node acredita estar correto








	int *r_aux = new int[n]; //LLR transformada em 1 e 0
	int *S = new int[n-k]; //sindrome
	int I = 0; //numero de iteraçoes
	int aux_S = 0; //auxiliar para saber se a sindrome é zero



	//mensagem tudo 0, com erro na posiçao 5

	for (int i = 0; i < n; i++)
	{
		//in[i] = 0;
	}
	//in[5] = 1;

	
	//mensagem gerada pelo matlab - se eu quiser uam entrada diferente de zero (short)
	FILE *ff = fopen("in_decoder.txt","r");

	for(int i = 0; i < n; i++)
	{
		fscanf(ff, "%i", &in[i]);
		printf("");
	}

	fclose(ff);
	

	//in[2] = in[2]^1; //inserindo erro
	in[4] = in[4]^1; //inserindo erro

	printf("");


	//copiar entrada
	for(int i = 0; i < n; i++)
	{
		r_aux[i] = in[i];
	}

	while(I < 50)
	{
		aux_S = 0;

		//zerar sindrome
		for(int i = 0; i < (n-k); i++)
		{
			S[i] = 0;
		}

		//calculo da sindrome
		for(int i = 0; i < (n-k); i++)
		{
			for(int j = 0; j < INDX[i]; j++)
			{
				S[i] = S[i] ^ r_aux[C[i][j]];
			}
		}

		//checar se sindrome � zero
		for(int i = 0; i < (n-k); i++)
		{
			aux_S = aux_S + S[i];
		}

		// mensagem ok
		if(aux_S == 0) 
		{
			printf("MENSAGEM OK. ITERACOES = %i\n", I);
			goto end;
		}
		else
		{
			I++;

			printf("ITERACAO %i\n", I);

			//zerar err
			for(int i = 0; i < n; i++)
			{
				err[i][0] = 0;
				err[i][1] = 0;
			}

			for(int i = 0; i < (n-k); i++) // cada fi (check node)
			{
				for(int j = 0; j < INDX[i]; j++) //cada cj (entrada ligada ao check node)
				{
					c_node = 0;
					for(int K = 0; K < INDX[i]; K++) //cada cK (entrada ligada ao check node, exceto cj)
					{
						if(K != j)
						{
							c_node = c_node^r_aux[C[i][K]];
						}
					}

					//contar 0s e 1s
					if(c_node == 0)
						err[C[i][j]][0]++;
					else if(c_node == 1)
						err[C[i][j]][1]++;

				}
				if(i%100 == 0)
					printf("f%i, INDX[i] = %i\n", i, INDX[i]);
			}

			for(int i = 0; i < n; i++)
			{
				//contar 0 e 1 na palavra codigo

				if(r_aux[i] == 0)
					err[i][0]++;
				else if(r_aux[i] == 1)
					err[i][1]++;


				//corrigir a palavra codigo

				if(err[i][0] > err[i][1])
				{
					if(r_aux[i] == 1)
						printf("%i INVERTEU DE 1 PARA 0 | 0 = %i | 1 = %i\n", i, err[i][0], err[i][1]);
					r_aux[i] = 0;
				}
				else if(err[i][0] < err[i][1])
				{
					if(r_aux[i] == 0)
						printf("%i INVERTEU DE 0 PARA 1 | 0 = %i | 1 = %i\n", i, err[i][0], err[i][1]);
					r_aux[i] = 1;
				}
			}
		}

		if(I == 50) //sair do loop se chegar ao max de iteracoes ou chegar em um "deadlock" 
		{
			printf("MENSAGEM NAO CORRIGIDA. ITERACOES = %i\n", I);
			goto end;
		}
	}

end:

	//r_aux é a mensagem corrigida, out é a saída, sem os bits de paridade
	for(int i = 0; i < n; i++)
	{
		//printf("%i ", r_aux[i]);
	}

	FILE *fff = fopen("OUT_LDPC_hard.txt", "w");
	fprintf(fff, "in  = ");
	for (int i = 0; i < n; i++)
	{
		fprintf(fff, "%i,", in[i]);
	}
	fprintf(fff, "\n");
	fprintf(fff, "out = ");
	for (int i = 0; i < n; i++)
	{
		fprintf(fff, "%i,", r_aux[i]);
	}
	fprintf(fff, "\n");
	fclose(fff);
	printf("OK OUT_LDPC_hard\n");




	delete [] r_aux;
	delete [] S;





	printf("");
	return 0;
}

